{
  "version": 3,
  "file": "bundle.css",
  "sources": [
    "App.svelte",
    "Action.svelte",
    "DisplayWords.svelte",
    "Result.svelte"
  ],
  "sourcesContent": [
    "<svelte:head>\n\t<link href=\"https://fonts.googleapis.com/css2?family=Montserrat:wght@400;500&display=swap\" rel=\"stylesheet\">\n</svelte:head>\n\n<script type=\"module\" lang=\"ts\">var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport DisplayWords from \"./component/DisplayWords.svelte\";\nimport Action from \"./component/Action.svelte\";\nimport Result from \"./component/Result.svelte\";\nimport API from \"../services/api\";\nimport { onMount } from 'svelte';\nlet wordLists = [];\nlet containerPosition = {\n    offsetTop: 0,\n    currentPositionTop: 0\n};\nlet currentWord = {\n    index: 0,\n    offsetTop: 0\n};\nlet keystrokes = {\n    total: 0,\n    incorrect: 0\n};\nlet result = false;\nonMount(() => __awaiter(void 0, void 0, void 0, function* () {\n    yield getWordLists();\n}));\nconst getWordLists = () => __awaiter(void 0, void 0, void 0, function* () {\n    wordLists = [];\n    const response = yield API.get();\n    const getSartingPoint = Math.floor(Math.random() * 1592);\n    const sentences = response.data.slice(getSartingPoint, getSartingPoint + 50);\n    wordLists = adjustArrayText(sentences);\n});\nconst adjustArrayText = (sentences) => {\n    const displayWords = [];\n    for (let i = 0; i < sentences.length; i++) {\n        const words = sentences[i].text.split(' ');\n        for (let j = 0; j < words.length; j++) {\n            if (displayWords.length === 250) {\n                return displayWords;\n            }\n            ;\n            displayWords.push({\n                text: words[j]\n            });\n        }\n    }\n};\n</script>\n\n<main>\n\t{#if !result}\n\t\t<DisplayWords bind:currentWord={currentWord} bind:wordLists={wordLists} bind:containerPosition={containerPosition} />\n\t{/if}\n\t<Action \n\t\ton:showResult={(value) => {\n\t\t\tresult = value.detail;\n\t\t}} \n\t\tbind:currentWord={currentWord} \n\t\tbind:wordLists={wordLists} \n\t\tbind:keystrokes={keystrokes}\n\t\ton:getWordLists={getWordLists} \n\t\tbind:containerPosition={containerPosition}/>\n\t{#if result}\n\t\t<Result \n\t\t\tbind:currentWord={currentWord}\n\t\t\tbind:keystrokes={keystrokes} \n\t\t\tbind:wordLists={wordLists}\n\t\t/>\n\t{/if}\n</main>\n\n<style lang=\"scss\">main {\n  text-align: center;\n  padding: 1em;\n  margin: 0 auto;\n  font-family: \"Montserrat\", sans-serif;\n}\n@media (min-width: 640px) {\n  main {\n    max-width: none;\n  }\n}</style>",
    "<script lang=\"ts\">var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n;\nimport { createEventDispatcher } from 'svelte';\nconst dispatch = createEventDispatcher();\nexport let currentWord;\nexport let wordLists;\nexport let containerPosition;\nexport let keystrokes;\nlet inputUser;\nlet game = {\n    start: false,\n    init: true,\n    finish: false\n};\nlet timer = {\n    interval: null,\n    minutes: 1,\n    seconds: 0\n};\nconst adjustDispayNumber = (number) => {\n    return number.toString().length === 1 ? '0' + number : number;\n};\nconst checkCurrentActiveWord = (typedWord, word) => {\n    for (let i = 0; i < typedWord.trim().length; i++) {\n        if (word[i] !== typedWord[i]) {\n            keystrokes.incorrect++;\n            wordLists[currentWord.index].incorrect = true;\n            break;\n        }\n    }\n};\nconst startTimer = () => {\n    timer.interval = setInterval(() => {\n        if (timer.seconds !== 0) {\n            timer.seconds--;\n        }\n        else if (timer.minutes !== 0) {\n            timer.minutes--;\n            if (timer.minutes === 0) {\n                timer.seconds = 59;\n            }\n        }\n        else {\n            finishGame();\n        }\n    }, 1000);\n};\nconst finishGame = () => {\n    clearInterval(timer.interval);\n    dispatch('showResult', true);\n    game.start = false;\n    game.finish = true;\n    inputUser = '';\n};\nconst startGame = () => {\n    if (!game.start) {\n        game.start = true;\n        game.init = false;\n        startTimer();\n    }\n    ;\n};\nconst checkGameProgress = () => {\n    return game.start;\n};\nconst userPressKey = ({ keyCode }) => {\n    const inGame = checkGameProgress();\n    if (!inGame) {\n        startGame();\n    }\n    const typedWord = inputUser || '';\n    const word = wordLists[currentWord.index].text;\n    wordLists[currentWord.index].incorrect = false;\n    if (keyCode === 32) {\n        procedNextWord(typedWord, word);\n    }\n    else {\n        keystrokes.total++;\n        checkCurrentActiveWord(typedWord, word);\n    }\n};\nconst procedNextWord = (typedWord, word) => {\n    const splittedInput = typedWord.split(' ');\n    updateLatestWordStatus(word, splittedInput[0]);\n    initFirstWord(splittedInput[1]);\n    moveDisplayWordPosition();\n};\nconst initFirstWord = (initWord) => {\n    inputUser = initWord || '';\n};\nconst moveDisplayWordPosition = () => {\n    currentWord.index++;\n    // inside HTMLElementTagNameMap interface there is HTMLSpanElement\n    // then we can use offsetTop property\n    const activeElement = document.querySelectorAll('.word')[currentWord.index];\n    if (activeElement && activeElement.offsetTop > currentWord.offsetTop) {\n        containerPosition.offsetTop += 52;\n        currentWord.offsetTop = activeElement.offsetTop;\n    }\n};\nconst updateLatestWordStatus = (activeWord, lastWord) => {\n    if (activeWord.trim() !== lastWord.trim()) {\n        wordLists[currentWord.index].incorrect = true;\n    }\n};\nconst restart = () => __awaiter(void 0, void 0, void 0, function* () {\n    clearInterval(timer.interval);\n    dispatch('showResult', false);\n    dispatch('getWordLists');\n    initFirstWord();\n    currentWord.index = 0;\n    containerPosition.offsetTop = 0;\n    currentWord.offsetTop = 0;\n    timer = {\n        minutes: 1,\n        interval: null,\n        seconds: 0\n    };\n    game = {\n        start: false,\n        init: true,\n        finish: false\n    };\n});\n</script>\n\n<div class=\"flex\">\n  <input type='text' bind:value=\"{inputUser}\" on:keyup={userPressKey} disabled={!game.init && !game.start}>\n  <div class=\"timer\">\n    <span class=\"{game.start ? 'timer-animation' : ''}\">\n      {adjustDispayNumber(timer.minutes)}:{adjustDispayNumber(timer.seconds)}\n    </span>\n  </div>\n  <button class=\"restart\" on:click={restart}>Restart</button>\n</div>\n\n<style lang=\"scss\">.flex {\n  display: flex;\n  justify-content: center;\n}\n\n.timer {\n  border: 1px solid #079e73;\n  margin: 0 0.5rem;\n  height: 35px;\n  line-height: 30px;\n  padding: 0 1rem;\n  font-weight: bold;\n}\n.timer .timer-animation {\n  animation: blinking 2s infinite;\n}\n@keyframes blinking {\n  0% {\n    opacity: 1;\n  }\n  50% {\n    opacity: 0;\n  }\n  100% {\n    opacity: 1;\n  }\n}\n\nbutton.restart {\n  background-color: #079e73;\n  border: 1px solid #18765b;\n  cursor: pointer;\n  color: white;\n  transition: background-color 250ms;\n}\nbutton.restart:hover {\n  background-color: #1ea780;\n}</style>",
    "<script lang=\"ts\">;\nexport let currentWord;\nexport let wordLists;\nexport let containerPosition;\nconst getClassWordBasedOnInput = (i, word) => {\n    if (currentWord.index === i) {\n        if (word.incorrect)\n            return 'active incorrect';\n        return 'active';\n    }\n    if (i < currentWord.index) {\n        if (word.incorrect)\n            return 'incorrect';\n        return 'correct';\n    }\n    return '';\n};\n</script>\n<div class=\"container\">\n  <div class=\"word-container\" style=\"bottom:{containerPosition.offsetTop}px\">\n    {#each wordLists as word, i}\n      <span class=\"word {getClassWordBasedOnInput(i, word)}\">{word.text}</span>\n    {/each}\n  </div>\n</div>\n\n<style lang=\"scss\">.container {\n  height: 110px;\n  overflow: hidden;\n  box-shadow: 0 4px 8px 0 rgba(0, 0, 0, 0.2);\n  max-width: 815px;\n  margin: auto;\n  background: #fff;\n  padding: 0.5rem 1rem;\n  margin-bottom: 1rem;\n}\n.container .word-container {\n  position: relative;\n  display: flex;\n  flex-wrap: wrap;\n}\n.container .word-container .word {\n  line-height: 1.5em;\n  font-size: 1.75em;\n  border-radius: 5px;\n  margin-bottom: 10px;\n  padding: 0 5px;\n  user-select: none;\n}\n.container .word-container .word.incorrect {\n  color: red;\n}\n.container .word-container .word.correct {\n  color: green;\n}\n.container .word-container .word.active {\n  background-color: #d4d3d3;\n}</style>",
    "<script lang=\"ts\">;\nexport let currentWord;\nexport let keystrokes;\nexport let wordLists;\nlet wpm;\nlet correctWords;\nlet incorrectWords;\nlet accuracy;\nconst calculateSummary = () => {\n    // since only one minute, all typed word until game finish is a wpm as well\n    wpm = calculateWPM();\n    correctWords = countCorrectWord();\n    incorrectWords = countIncorrectWord(wpm, correctWords);\n    accuracy = calculateAccuracy(keystrokes.total, keystrokes.incorrect);\n};\nconst calculateWPM = () => {\n    const typedWords = getTypedWord();\n    const totalWords = typedWords.length;\n    return totalWords;\n};\nconst countCorrectWord = () => {\n    const typedWords = getTypedWord();\n    let total = 0;\n    typedWords.forEach((item) => {\n        if (!item.incorrect) {\n            total++;\n        }\n    });\n    return total;\n};\nconst countIncorrectWord = (totalWords, correctWords) => {\n    return wpm - correctWords;\n};\nconst calculateAccuracy = (totalKeystroke, incorrectKey) => {\n    return Math.floor((totalKeystroke - incorrectKey) / totalKeystroke * 100);\n};\nconst getTypedWord = () => {\n    return wordLists.slice(0, currentWord.index);\n};\ncalculateSummary();\n</script>\n<div class=\"result\">\n  <div class=\"result__summary\">\n    {wpm} WPM\n  </div>\n  <table class=\"result__detail\">\n    <tr class=\"detail__text\">\n      <td>Keystrokes</td>\n      <td>:</td>\n      <td><span class=\"correct\">{keystrokes.total - keystrokes.incorrect}</span> | <span class=\"incorrect\">{keystrokes.incorrect}</span></td>\n    </tr>\n    <tr class=\"detail__text\">\n      <td>Accuracy</td>\n      <td>:</td>\n      <td>{accuracy}%</td>\n    </tr>\n    <tr class=\"detail__text\">\n      <td>Correct word(s)</td>\n      <td>:</td>\n      <td><span class=\"correct\">{correctWords}</span></td>\n    </tr>\n    <tr class=\"detail__text\">\n      <td>Wrong word(s)</td>\n      <td>:</td>\n      <td><span class=\"incorrect\">{incorrectWords}</span></td>\n    </tr>\n  </table>\n</div>\n\n<style lang=\"scss\">.result {\n  display: flex;\n  justify-content: center;\n}\n.result .result__summary {\n  font-weight: bold;\n  font-size: 3rem;\n  color: #079e73;\n  padding: 1rem;\n}\n.result .result__detail {\n  display: flex;\n  flex-direction: column;\n}\n.result .result__detail .detail__text {\n  margin-top: 0;\n  margin-bottom: 0.5rem;\n  text-align: left;\n}\n.result .result__detail .detail__text td:first-child {\n  width: 130px;\n}\n.result .result__detail .detail__text .correct {\n  color: #079e73;\n}\n.result .result__detail .detail__text .incorrect {\n  color: #d20f0f;\n}</style>"
  ],
  "names": [],
  "mappings": "AAiFmB,IAAI,cAAC,CAAC,AACvB,UAAU,CAAE,MAAM,CAClB,OAAO,CAAE,GAAG,CACZ,MAAM,CAAE,CAAC,CAAC,IAAI,CACd,WAAW,CAAE,YAAY,CAAC,CAAC,UAAU,AACvC,CAAC,AACD,MAAM,AAAC,YAAY,KAAK,CAAC,AAAC,CAAC,AACzB,IAAI,cAAC,CAAC,AACJ,SAAS,CAAE,IAAI,AACjB,CAAC,AACH,CAAC;ACqDkB,KAAK,4BAAC,CAAC,AACxB,OAAO,CAAE,IAAI,CACb,eAAe,CAAE,MAAM,AACzB,CAAC,AAED,MAAM,4BAAC,CAAC,AACN,MAAM,CAAE,GAAG,CAAC,KAAK,CAAC,OAAO,CACzB,MAAM,CAAE,CAAC,CAAC,MAAM,CAChB,MAAM,CAAE,IAAI,CACZ,WAAW,CAAE,IAAI,CACjB,OAAO,CAAE,CAAC,CAAC,IAAI,CACf,WAAW,CAAE,IAAI,AACnB,CAAC,AACD,oBAAM,CAAC,gBAAgB,cAAC,CAAC,AACvB,SAAS,CAAE,sBAAQ,CAAC,EAAE,CAAC,QAAQ,AACjC,CAAC,AACD,WAAW,sBAAS,CAAC,AACnB,EAAE,AAAC,CAAC,AACF,OAAO,CAAE,CAAC,AACZ,CAAC,AACD,GAAG,AAAC,CAAC,AACH,OAAO,CAAE,CAAC,AACZ,CAAC,AACD,IAAI,AAAC,CAAC,AACJ,OAAO,CAAE,CAAC,AACZ,CAAC,AACH,CAAC,AAED,MAAM,QAAQ,4BAAC,CAAC,AACd,gBAAgB,CAAE,OAAO,CACzB,MAAM,CAAE,GAAG,CAAC,KAAK,CAAC,OAAO,CACzB,MAAM,CAAE,OAAO,CACf,KAAK,CAAE,KAAK,CACZ,UAAU,CAAE,gBAAgB,CAAC,KAAK,AACpC,CAAC,AACD,MAAM,oCAAQ,MAAM,AAAC,CAAC,AACpB,gBAAgB,CAAE,OAAO,AAC3B,CAAC;AC3JkB,UAAU,4BAAC,CAAC,AAC7B,MAAM,CAAE,KAAK,CACb,QAAQ,CAAE,MAAM,CAChB,UAAU,CAAE,CAAC,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,CAC1C,SAAS,CAAE,KAAK,CAChB,MAAM,CAAE,IAAI,CACZ,UAAU,CAAE,IAAI,CAChB,OAAO,CAAE,MAAM,CAAC,IAAI,CACpB,aAAa,CAAE,IAAI,AACrB,CAAC,AACD,wBAAU,CAAC,eAAe,cAAC,CAAC,AAC1B,QAAQ,CAAE,QAAQ,CAClB,OAAO,CAAE,IAAI,CACb,SAAS,CAAE,IAAI,AACjB,CAAC,AACD,wBAAU,CAAC,eAAe,CAAC,KAAK,cAAC,CAAC,AAChC,WAAW,CAAE,KAAK,CAClB,SAAS,CAAE,MAAM,CACjB,aAAa,CAAE,GAAG,CAClB,aAAa,CAAE,IAAI,CACnB,OAAO,CAAE,CAAC,CAAC,GAAG,CACd,WAAW,CAAE,IAAI,AACnB,CAAC,AACD,wBAAU,CAAC,eAAe,CAAC,KAAK,UAAU,cAAC,CAAC,AAC1C,KAAK,CAAE,GAAG,AACZ,CAAC,AACD,wBAAU,CAAC,eAAe,CAAC,KAAK,QAAQ,cAAC,CAAC,AACxC,KAAK,CAAE,KAAK,AACd,CAAC,AACD,wBAAU,CAAC,eAAe,CAAC,KAAK,OAAO,cAAC,CAAC,AACvC,gBAAgB,CAAE,OAAO,AAC3B,CAAC;ACYkB,OAAO,4BAAC,CAAC,AAC1B,OAAO,CAAE,IAAI,CACb,eAAe,CAAE,MAAM,AACzB,CAAC,AACD,qBAAO,CAAC,gBAAgB,cAAC,CAAC,AACxB,WAAW,CAAE,IAAI,CACjB,SAAS,CAAE,IAAI,CACf,KAAK,CAAE,OAAO,CACd,OAAO,CAAE,IAAI,AACf,CAAC,AACD,qBAAO,CAAC,eAAe,cAAC,CAAC,AACvB,OAAO,CAAE,IAAI,CACb,cAAc,CAAE,MAAM,AACxB,CAAC,AACD,qBAAO,CAAC,eAAe,CAAC,aAAa,cAAC,CAAC,AACrC,UAAU,CAAE,CAAC,CACb,aAAa,CAAE,MAAM,CACrB,UAAU,CAAE,IAAI,AAClB,CAAC,AACD,qBAAO,CAAC,eAAe,CAAC,aAAa,CAAC,gBAAE,YAAY,AAAC,CAAC,AACpD,KAAK,CAAE,KAAK,AACd,CAAC,AACD,qBAAO,CAAC,eAAe,CAAC,aAAa,CAAC,QAAQ,cAAC,CAAC,AAC9C,KAAK,CAAE,OAAO,AAChB,CAAC,AACD,qBAAO,CAAC,eAAe,CAAC,aAAa,CAAC,UAAU,cAAC,CAAC,AAChD,KAAK,CAAE,OAAO,AAChB,CAAC"
}